// This example demonstrates the proc macro functionality of the azolla-client crate
// It shows how to use the #[azolla_task] macro to create type-safe task definitions

use azolla_client::{
    azolla_task, Client, TaskError, TaskExecutionOutcome, Worker, WorkerInvocation,
};
use serde_json::{json, Value};

/// Simple function-based task using the proc macro
#[azolla_task]
async fn greet_user(name: String, age: u32) -> Result<Value, TaskError> {
    if name.is_empty() {
        return Err(TaskError::invalid_args("Name cannot be empty"));
    }

    Ok(json!({
        "greeting": format!("Hello, {name}! You are {age} years old."),
        "name": name,
        "age": age
    }))
}

/// Math calculation task
#[azolla_task]
async fn calculate_fibonacci(n: u32) -> Result<Value, TaskError> {
    if n > 50 {
        return Err(TaskError::invalid_args("Number too large (max 50)"));
    }

    let result = fibonacci(n);
    Ok(json!({
        "input": n,
        "result": result,
        "calculation": "fibonacci"
    }))
}

/// Helper function for fibonacci calculation
fn fibonacci(n: u32) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        _ => fibonacci(n - 1) + fibonacci(n - 2),
    }
}

/// Task with optional parameters
#[azolla_task]
async fn process_data(
    input: String,
    format: Option<String>,
    validate: bool,
) -> Result<Value, TaskError> {
    let format = format.unwrap_or_else(|| "json".to_string());

    if validate && input.len() < 5 {
        return Err(TaskError::execution_failed(
            "Input too short for validation",
        ));
    }

    Ok(json!({
        "processed_input": input.to_uppercase(),
        "format": format,
        "validated": validate,
        "length": input.len()
    }))
}

/// Task with array input
#[azolla_task]
async fn sum_numbers(numbers: Vec<i32>) -> Result<Value, TaskError> {
    if numbers.is_empty() {
        return Err(TaskError::invalid_args("Numbers array cannot be empty"));
    }

    let sum: i32 = numbers.iter().sum();
    let avg = sum as f64 / numbers.len() as f64;

    Ok(json!({
        "numbers": numbers,
        "sum": sum,
        "average": avg,
        "count": numbers.len()
    }))
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("🚀 Azolla Proc Macro Tasks Example");

    // Create client
    let _client = Client::builder()
        .endpoint("http://localhost:52710")
        .domain("proc-macro-examples")
        .build()
        .await?;

    println!("📡 Client created (minimal stub for demonstration)");

    // Show task generation (the key feature of this example)
    println!("\n📝 Task structs generated by proc macro:");
    println!("   - GreetUserTask (from greet_user function)");
    println!("   - CalculateFibonacciTask (from calculate_fibonacci function)");
    println!("   - ProcessDataTask (from process_data function)");
    println!("   - SumNumbersTask (from sum_numbers function)");

    // Example of how task submission would work:
    println!("\n📝 Task submission examples (for reference):");
    println!("   client.submit_task(\"greet_user\").args((\"Alice\".to_string(), 25u32))");
    println!("   client.submit_task(\"calculate_fibonacci\").args(10u32)");
    println!("   client.submit_task(\"process_data\").args((\"Hello World\".to_string(), Some(\"xml\".to_string()), true))");
    println!("   client.submit_task(\"sum_numbers\").args(vec![1, 2, 3, 4, 5])");

    // Create worker with auto-generated task structs
    println!("\n🔧 Creating worker with proc macro tasks...");

    let worker = Worker::builder()
        .register_task(GreetUserTask) // Generated by proc macro
        .register_task(CalculateFibonacciTask) // Generated by proc macro
        .register_task(ProcessDataTask) // Generated by proc macro
        .register_task(SumNumbersTask) // Generated by proc macro
        .build();

    println!("✅ Worker created with {} tasks", worker.task_count());

    println!("\n🧪 Running one of the generated tasks locally...");
    let invocation = WorkerInvocation::from_json(
        &uuid::Uuid::new_v4().to_string(),
        "sum_numbers",
        "[[1,2,3,4,5]]",
        "{}",
        "http://127.0.0.1:50052",
    )?;

    let execution = worker.execute(&invocation).await;
    match execution.outcome {
        TaskExecutionOutcome::Success(value) => {
            println!("   ✅ sum_numbers output: {value}");
        }
        TaskExecutionOutcome::Failed(error) => {
            println!("   ❌ sum_numbers failed: {error}");
        }
    }

    println!("\n🎉 Example completed successfully!");
    println!("💡 The proc macro generated type-safe task wrappers that:");
    println!("   - Extract typed arguments from JSON");
    println!("   - Handle argument validation");
    println!("   - Provide compile-time type checking");
    println!("   - Generate task registration code");

    Ok(())
}
