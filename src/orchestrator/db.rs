use anyhow::Result;
use config::{Config, ConfigError, Environment, File};
use deadpool_postgres::{Manager, Pool};
use openssl::ssl::{SslConnector, SslMethod, SslVerifyMode};
use postgres_openssl::MakeTlsConnector;
use serde::Deserialize;
use std::collections::HashMap;
use tokio_postgres::NoTls;

// Embed the migrations module generated by refinery
mod migrations {
    refinery::embed_migrations!();
}

#[derive(Debug, Deserialize, Clone)]
pub struct Database {
    pub url: String,
    #[serde(default = "default_pool_size")]
    pub pool_size: usize,
}

#[derive(Debug, Deserialize, Clone)]
pub struct Server {
    pub port: u16,
}

#[derive(Debug, Deserialize, Clone)]
pub struct EventStream {
    pub max_batch_size: usize,
    pub adaptive_threshold: usize,
    pub max_wait_time_ms: u64,
    pub channel_capacity: usize,
}

impl Default for EventStream {
    fn default() -> Self {
        Self {
            max_batch_size: 100,
            adaptive_threshold: 10,
            max_wait_time_ms: 1,
            channel_capacity: 1000,
        }
    }
}

#[derive(Debug, Deserialize, Clone)]
pub struct DomainConfig {
    pub concurrency_limit: u32,
    #[serde(default = "default_shepherd_group")]
    pub default_shepherd_group: String,
}

#[derive(Debug, Deserialize, Clone)]
pub struct DomainsConfig {
    pub default_concurrency_limit: u32,
    #[serde(default)]
    pub specific: HashMap<String, DomainConfig>,
}

impl Default for DomainsConfig {
    fn default() -> Self {
        Self {
            default_concurrency_limit: 100,
            specific: HashMap::new(),
        }
    }
}

fn default_shepherd_group() -> String {
    "default".to_string()
}

#[derive(Debug, Deserialize, Clone)]
pub struct ShutdownConfig {
    pub timeout_secs: u64,
}

impl Default for ShutdownConfig {
    fn default() -> Self {
        Self {
            timeout_secs: 30, // Production default: 30 seconds
        }
    }
}

#[derive(Debug, Deserialize, Clone)]
pub struct Settings {
    pub database: Database,
    pub server: Server,
    #[serde(default)]
    pub event_stream: EventStream,
    #[serde(default)]
    pub domains: DomainsConfig,
    #[serde(default)]
    pub shutdown: ShutdownConfig,
}

fn default_pool_size() -> usize {
    8
}

impl Settings {
    pub fn new() -> Result<Self, ConfigError> {
        let s = Config::builder()
            .add_source(File::with_name("config/orchestrator").required(false))
            .add_source(Environment::with_prefix("AZOLLA").separator("__"))
            .build()?;
        s.try_deserialize()
    }
}

pub type PgPool = deadpool_postgres::Pool;

pub fn create_pool(settings: &Settings) -> Result<PgPool> {
    let pg_config = settings.database.url.parse::<tokio_postgres::Config>()?;

    if pg_config.get_ssl_mode() == tokio_postgres::config::SslMode::Disable {
        let manager = Manager::new(pg_config, NoTls);
        let pool = Pool::builder(manager)
            .max_size(settings.database.pool_size)
            .build()?;
        Ok(pool)
    } else {
        let mut builder = SslConnector::builder(SslMethod::tls())?;
        builder.set_verify(SslVerifyMode::NONE);
        let connector = MakeTlsConnector::new(builder.build());

        let manager = Manager::new(pg_config, connector);
        let pool = Pool::builder(manager)
            .max_size(settings.database.pool_size)
            .build()?;
        Ok(pool)
    }
}

pub async fn run_migrations(pool: &PgPool) -> Result<()> {
    log::info!("Running database migrations...");
    let mut client = pool.get().await?;
    migrations::migrations::runner()
        .run_async(&mut **client)
        .await?;
    log::info!("Database migrations completed.");
    Ok(())
}
